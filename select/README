选择排序类有：简单的选择排序和堆排序两种
简单的选择排序：
思想：(这里我们按照从小到大排序)假设前i-1个元素已经有序，现在我们
要在剩下的元素中找到最小的那个元素将它和第i个元素交换位置，，现在要做的
就是从i+1个元素开始向后遍历比较找到最小的元素纪录下他的下标。不过遍历一遍后
为了防止自己和自己交换(也就是第i个元素就是最小的)，我们要判断一下。如果
(min!=i)我们才交换。
堆排序：
思想：堆排序其实总的来说就分两步：第一步-》建堆，第二步-》自上而下调整
困难的是第一步建堆的过程。其实想想我们建堆的目的是什么，就是使数据从
二叉树的角度上看基本有序，孩子节点的值都小于父节点的值，如果达到这样
的效果，那么我们第二步调整时就很容易了。第一步完成后，接下来就是取值、
重复调整的过程。
来分析一下代码：建堆，我们从节点最大的那个父节点开始，开始循环
调整。寻找儿子节点中较大的节点和父节点比较，如果比父节点大，则交换
(注意，一旦交换，那么必须要执行循环调整，因为下面的树形可能已经不满足
大根堆的要求了。dad=son;son=2*dad+1;这两句代码很重要)。如果是其他情况
直接结束。
堆建好后，开始调整。在我们程序中建完堆后我们把第一个元素和最后一个
交换了。现在大根堆被破坏了，第一个元素肯定不满足大根堆，所以我们
要自上而下进行调整。我们还需要调整N-1次，因为建堆的过程其实也是
一次取最大值的过程。(建完堆后我们交换了a[0]和a[N-1],最大值这时在a[N-1])
中。
